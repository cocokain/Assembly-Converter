<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Switch ASM Converter</title>

    <script src="keystone.min.js" defer></script>
    <style>
        body {
            font-family: 'PlemolJP', 'メイリオ', monospace;
            margin: 0;
            background-color: #343238;
            color: #ffffff;
            display: flex;
            flex-direction: column;
            min-height: 100vh;
        }
        .container {
            background-color: #292424;
            padding: 25px;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(255, 0, 0, 0.1);
            /* ここを修正：max-width を削除し、width: 100% に変更 */
            width: 100%; /* 画面の横幅全体を使う */
            /* margin: 20px auto; は上下のマージンとして残し、左右中央揃えを解除 */
            margin-top: 20px;
            margin-bottom: 20px;
            /* margin-left/right は auto を削除し、padding で内側に寄せる */
            /* もしくは、padding で左右の内側余白を設ける */
            
            /* padding が内側の余白になるので、これで十分全画面感が出るはず */

            flex-grow: 1;
            display: flex;
            flex-direction: column;
        }
        h1 {
            text-align: center;
            color: #ffe600;
            margin-bottom: 30px;
        }
        label {
            display: block;
            margin-bottom: 8px;
            font-weight: bold;
            color: #e5ff00;
        }

        .editor-container {
            display: flex;
            gap: 20px;
            flex-grow: 1;
            margin-bottom: 20px;
            overflow: visible; /* 疑似要素のボーダーが切れないように */
        }

        .editor-block {
            display: flex;
            flex-direction: column;
            flex: 1;
            box-sizing: border-box;
        }

        /* 右側のボックス（出力）の端が切れる問題に対応 */
        .editor-block:last-child {
            padding-right: 6px; /* 右側に余白を与えてボーダーを見えるようにする */
        }

        .code-input-wrapper {
            display: flex;
            flex-grow: 1;
            position: relative;
            border-radius: 6px;
            overflow: visible;
        }

        /* 汎用の虹色ボーダークラス（内側の背景色は --inner-bg で指定） */
        .rainbow-border {
            position: relative;
            border: 3px solid transparent;
            border-radius: 6px;
            background-image: linear-gradient(var(--inner-bg, #292727), var(--inner-bg, #292727)), linear-gradient(90deg, #ff0000, #ff7f00, #ffff00, #00ff00, #00ffff, #0000ff, #8b00ff, #ff0000);
            background-origin: padding-box, border-box;
            background-clip: padding-box, border-box;
            background-size: auto, 200% 100%;
            animation: rainbow-flow 3s linear infinite;
        }

        /* テキストエリア類を前面に出す */
        .rainbow-border textarea,
        .rainbow-border .line-numbers {
            position: relative;
            z-index: 1;
        }

        /* （直前の変更を元に戻しました：幅制約は解除） */

        @keyframes rainbow-flow {
            0% { background-position: 0% 50%; }
            100% { background-position: 200% 50%; }
        }

        .line-numbers {
            width: 40px;
            padding: 12px 5px;
            background-color: #3b3939;
            color: #dadada;
            text-align: right;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
            overflow-y: hidden;
            resize: none;
            border: none;
            box-sizing: border-box;
            pointer-events: none;
            user-select: none;
        }

        #assemblyCode {
            min-height: 300px; /* 最小の高さを設定 */
            flex-grow: 1;
            padding: 12px;
            background-color: #292727;
            color: #ffffff;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            border: none;
            box-sizing: border-box;
            white-space: pre;
            overflow-y: auto;
        }
        #outputArea {
            min-height: 300px; /* 最小の高さを設定 */
            flex-grow: 1;
            padding: 12px;
            background-color: #413f3f;
            --inner-bg: #413f3f;
            color: #e0e0e0;
            font-family: 'Courier New', Courier, monospace;
            font-size: 14px;
            line-height: 1.5;
            resize: none;
            border-radius: 6px;
            box-sizing: border-box;
            overflow-y: auto;
        }

        #outputArea.error-state {
            background-color: #3b3939;
            --inner-bg: #3b3939;
            color: #ff0000;
        }

        button {
            display: block;
            width: 100%;
            padding: 12px;
            background-color: #363738;
            color: rgb(233, 231, 231);
            border: none;
            border-radius: 6px;
            font-size: 17px;
            cursor: pointer;
            transition: background-color 0.3s ease, transform 0.1s ease;
            margin-top: 20px;
        }
        button:hover {
            background-color: #0056b3;
            transform: translateY(-2px);
        }
        button:active {
            transform: translateY(0);
        }

        .option-group {
            margin-top: 20px;
            margin-bottom: 20px;
            padding: 10px;
            border-radius: 6px;
            background-color: #3b3939;
            --inner-bg: #3b3939;
        }
        .option-group label {
            display: inline-block;
            margin-right: 15px;
            font-weight: normal;
            cursor: pointer;
        }
        .option-group input[type="radio"] {
            margin-right: 5px;
        }

        /* Footer styling: 中央寄せ、前面に出す */
        footer {
            text-align: center;
            position: relative;
            z-index: 3;
            color: #e0e0e0;
            padding: 12px 0 20px;
        }

        footer a { color: #9fd1ff; }

        /* 小さなBGMオン/オフトグル（目立たない場所に表示） */
        .music-toggle {
            position: fixed;
            right: 12px;
            bottom: 12px;
            z-index: 10000;
        }
        .music-toggle button {
            width: 36px;
            height: 36px;
            border-radius: 50%;
            border: none;
            background: rgba(41,36,36,0.85);
            color: #fff;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 16px;
            cursor: pointer;
            box-shadow: 0 2px 6px rgba(0,0,0,0.4);
            backdrop-filter: blur(4px);
        }
        .music-toggle button.on {
            background: linear-gradient(180deg,#48c774,#2ecc71);
            color: #062;
            box-shadow: 0 4px 10px rgba(46,204,113,0.25);
        }
        .music-toggle button.off {
            background: rgba(41,36,36,0.85);
            color: #fff;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>Switch ASM Converter</h1>

        <div class="instruction-text">
            <p>このツールは、ARM64アセンブリコードをSwitchのチートコードに変換します。以下の点にご注意ください。</p>
            <ul>
                <li><strong>オフセットの指定:</strong> コードの最初の行に <code>0x1000 ; function</code> のような16進数形式で、コードブロックの開始アドレスを指定してください。</li>
                <li><strong>分岐命令のアドレス解決:</strong><br>
                    アセンブラはすべての分岐命令について絶対アドレスとして処理します。
                </li>
                <li><strong>ラベルの扱い:</strong>
                    各行のアセンブリコードの最後で <code>&lt;= ラベル名</code> の形式で定義したラベルは、内部的にその命令ブロックの先頭からの**絶対アドレス**として処理されます。コード中でこのラベル名を参照できます。
                    <ul>
                        <li>0x100 ; ラベルの例</li>
                        <li>CBZ W0, _SkipFunction</li>
                        <li>BL 0x1000</li>
                        <li>RET &lt;= _SkipFunction</li>
                    </ul>
                </li>
            </ul>
        </div>

        <div class="editor-container">
            <div class="editor-block">
                <label for="assemblyCode">ソースコード</label>
                <div class="code-input-wrapper rainbow-border">
                    <textarea class="line-numbers" readonly></textarea>
                    <textarea id="assemblyCode" placeholder="0x1000 ; myCode&#10;ret"></textarea>
                </div>
            </div>

            <div class="editor-block">
                <label for="outputArea">結果 / エラー:</label>
                <textarea id="outputArea" readonly class="rainbow-border"></textarea>
            </div>
        </div>

        <div class="option-group rainbow-border">
            <strong>出力形式を選択:</strong>
            <div>
                <input type="radio" id="formatIPS" name="outputFormat" value="ips" checked>
                <label for="formatIPS">IPS形式</label>
            </div>
            <div>
                <input type="radio" id="formatEdiZon" name="outputFormat" value="edizon">
                <label for="formatEdiZon">EdiZon形式</label>
            </div>
            <div>
                <input type="radio" id="formatRaw" name="outputFormat" value="raw">
                <label for="formatRaw">RAW機械語</label>
            </div>
        </div>

        <button id="convertButton">変換</button>
    </div>

    <footer>
        <p>
            このツールは、
            <a href="https://github.com/AlexAltea/keystone.js?tab=BSD-3-Clause-1-ov-file" target="_blank" rel="noopener noreferrer">
                Keystone.js
            </a>
            ライブラリ（BSD-3-Clauseライセンス）を利用しています。
        </p>
        <p class="footer-copy">&copy; 2025 @KAIN. All rights reserved.
            Discord:@yml_xyz
        </p>
    </footer>

    <!-- BGM オーディオ（自動再生する決まった曲を再生） -->
    <audio id="bgm" loop preload="auto"></audio>
    <!-- 小さなオン/オフ切替ボタン -->
    <div class="music-toggle">
        <button id="bgmToggle" aria-pressed="false" title="BGM ON/OFF">♪</button>
    </div>

    <script>

        function removeComment(input) {
            return input.split('\n').map(line => line.split(';')[0])
        }


        function cheatCoding(codeparts, offset) {
            let code = "";
            
            for (let i = 0; i < Math.floor(codeparts.length / 2); i++) {
                code += `08000000 ${ (offset + 8 * i).toString(16).padStart(8, '0').toUpperCase()} ${codeparts[2 * i + 1].trim()} ${codeparts[2 * i].trim()}\n`;
            }

            if (codeparts.length % 2 === 1) {
                code += `04000000 ${(offset + 4 * (codeparts.length - 1)).toString(16).padStart(8, '0').toUpperCase()} ${codeparts[codeparts.length - 1].trim()}\n`;
            }
            return code;
        }
        
        function ipsCoding(codeparts, offset) {
            let code = ""
            let i = 0

            for (const part of codeparts) {
                if (i % 10 === 0) {
                    if (i !== 0) {
                        code += "\n";
                    }
                    code += `${ (offset + 4 * i).toString(16).padStart(8, '0').toUpperCase()} `;
                }
                code += part.trim();
                i += 1;
            }

            return code;
        }

        function convertEndian(parts) {

            const result = parts.map(part => {
                const bytes = part.match(/.{2}/g);
                if (!bytes) return '';
                return bytes.reverse().join('');
            });

            return result
        }

        function inputLabels(lines,offset,errorLogs) {
            var labels = []
            var pos = []
            for (let i in lines) {
                var match = lines[i].match(/<=(.+)/)
                if (match) {
                    var label = match[1].trim()
                    for (let i = 0; i < labels.length; i++) {
                    if (labels[i].includes(label)||label.includes(labels[i])) {
                        errorLogs.push(`ラベルミス: 同名か似た名前のラベル '${label}' が複数存在します`);
                        throw `ラベルミス: 同名か似た名前のラベル '${label}' が複数存在します`
                    }
                    }
                    lines[i] = lines[i].split("<=")[0]
                    labels.push([ label, offset + 4 * i])
                }
            }
            for (let j in labels) {
                for (let i in lines) {
                    if(!lines[i].includes(labels[j][0])) continue;

                    if (lines[i].startsWith("bl") || lines[i].startsWith("b ")) {
                        lines[i] = lines[i].replace(new RegExp(labels[j][0], 'g'),"0x"+ labels[j][1].toString(16).padStart(8, '0'))
                    }else{
                        lines[i] = lines[i].replace(new RegExp(labels[j][0], 'g'),"#" + String(labels[j][1] - (offset + i*4)))
                    }
                }
            }
            return lines
        }
        
        function extractADRPAddress(line) {
            const adrpPattern = /^\s*adrp\s+[xX]\d+,\s*(.+)$/i;
            const match = line.match(adrpPattern);
            if (match && match[1]) {
                return match[1].trim();
            }
            return null; // マッチしなかった場合
        }

        function fromAbsolute(lines,offset){
            for (let i in lines) {
                if (lines[i].startsWith("adrp")) {
                    lines[i] = lines[i].replace(new RegExp(extractADRPAddress(lines[i]), 'g'),"#" + (parseInt(extractADRPAddress(lines[i]).replace(/#?0x/i, ''),16) - ((offset + i*4) - (offset + i*4) % (16 * 16 * 16))))
                }
            }
            return lines
        }
        
        // Keystoneインスタンスを格納する変数名を変更して衝突を避ける
        let keystoneAssembler;

        // --- Main Logic (DOMContentLoaded) ---
        document.addEventListener('DOMContentLoaded', () => {
            const assemblyCodeTextArea = document.getElementById('assemblyCode');
            const lineNumbersTextArea = document.querySelector('.line-numbers');
            const convertButton = document.getElementById('convertButton');
            const outputArea = document.getElementById('outputArea');

            // 行番号の更新
            const updateLineNumbers = () => {
                const lines = assemblyCodeTextArea.value.split('\n');
                const lineCount = Math.max(1, lines.length); // 少なくとも1行は表示
                lineNumbersTextArea.value = Array.from({ length: lineCount }, (_, i) => i + 1).join('\n');
                
                // コードエリアと行番号エリアのスクロール同期
                lineNumbersTextArea.scrollTop = assemblyCodeTextArea.scrollTop;
            };

            assemblyCodeTextArea.addEventListener('input', updateLineNumbers);
            assemblyCodeTextArea.addEventListener('scroll', updateLineNumbers);

            // 初期表示
            updateLineNumbers();

            try {
                keystoneAssembler = new ks.Keystone(ks.ARCH_ARM64, ks.MODE_LITTLE_ENDIAN);
                console.log("Keystone.js が正常に初期化されました。");
            } catch (initError) {
                outputArea.value = `エラー: Keystone.jsの初期化に失敗しました。keystone.min.jsが正しく読み込まれているか確認してください。 (${initError.message})`;
                outputArea.classList.add('error-state');
                console.error('Keystone.js 初期化エラー:', initError);
                convertButton.disabled = true;
                return;
            }

            if (convertButton) {
                convertButton.addEventListener('click', assembleCode);
            } else {
                console.error("エラー: 'convertButton' IDのボタンが見つかりません。");
            }
        });

        // --- Simple autoplay + small toggle ---
        (function(){
            const bgm = document.getElementById('bgm');
            const toggle = document.getElementById('bgmToggle');

            // 既定の曲を設定（リポジトリに `assets/bgmusic.mp3` を置いてください）
            bgm.src = 'assets/bgmusic.mp3';

            // 再生を試みる（ブラウザポリシーでブロックされる場合あり）
            function tryAutoplay(){
                bgm.play().then(()=>{
                    // 再生成功 -> ON 表示（音符）
                    toggle.textContent = '♪';
                    toggle.classList.add('on');
                    toggle.classList.remove('off');
                    toggle.setAttribute('aria-pressed','true');
                    toggle.title = 'BGM: ON (クリックでOFF)';
                }).catch(()=>{
                    // ブロックされた場合は停止扱い（✖ 表示）
                    toggle.textContent = '✖';
                    toggle.classList.add('off');
                    toggle.classList.remove('on');
                    toggle.setAttribute('aria-pressed','false');
                    toggle.title = 'BGM: OFF (クリックでON)';
                });
            }

            // ページ読み込み時に自動で再生を試みる
            tryAutoplay();

            // または、ユーザーの最初の操作で再生を開始（フォールバック）
            function userGestureStart(){
                tryAutoplay();
                window.removeEventListener('click', userGestureStart);
                window.removeEventListener('keydown', userGestureStart);
            }
            window.addEventListener('click', userGestureStart, { once: true });
            window.addEventListener('keydown', userGestureStart, { once: true });

            // トグルでオン/オフ（見た目：再生->♪ , 停止->✖）
            toggle.addEventListener('click', () => {
                if (bgm.paused) {
                    bgm.play().then(()=>{
                        toggle.textContent = '♪';
                        toggle.classList.add('on');
                        toggle.classList.remove('off');
                        toggle.setAttribute('aria-pressed','true');
                        toggle.title = 'BGM: ON (クリックでOFF)';
                    }).catch(()=>{});
                } else {
                    bgm.pause();
                    toggle.textContent = '✖';
                    toggle.classList.add('off');
                    toggle.classList.remove('on');
                    toggle.setAttribute('aria-pressed','false');
                    toggle.title = 'BGM: OFF (クリックでON)';
                }
            });
        })();

        function assembleCode() {
            const assemblyCode = document.getElementById('assemblyCode').value;
            var lines = removeComment(assemblyCode.toLowerCase())
            const offsetHex = lines.shift()
            const offset = parseInt(offsetHex, 16);

            const selectedFormat = document.querySelector('input[name="outputFormat"]:checked').value;

            outputArea.value = '';
            outputArea.classList.remove('error-state'); 

            if (!assemblyCode.trim()) {
                outputArea.value = 'オフセットを入力'
                outputArea.classList.add('error-state'); // エラー時スタイル適用
                return;
            }
            if (isNaN(offset)) {
                outputArea.value = '無効なオフセット値です。16進数で入力してください (例: 0x1000)。'
                outputArea.classList.add('error-state'); // エラー時スタイル適用
                return;
            }
            const errorLogs = []; // エラーログを格納する配列
            try {
                
                lines = inputLabels(lines,offset,errorLogs)
                lines = fromAbsolute(lines,offset).filter(line => line.trim() !== '');
                const machineCodeParts = []; // 各行の機械語を格納する配列

                for (let i = 0; i < lines.length; i++) {
                    const lineCode = lines[i];
                    // 各行のコードに対して、その行のオフセットを計算
                    // ARM64の命令は通常4バイトなので、行番号 * 4 を現在のオフセットに加算
                    const currentOffset = offset + (i * 4);
                    var temp = ""
                    try {
                        // 各行のアセンブルを実行
                        const result = keystoneAssembler.asm(lineCode, currentOffset);
                        for (let j = 3; j >= 0; j--) {
                            temp += result[j].toString(16).padStart(2, '0').toUpperCase();
                        }
                        machineCodeParts.push(temp); // 機械語を配列に追加
                    } catch (innerError) {
                        // 各行のアセンブル中に例外が発生した場合
                        errorLogs.push(`${i + 2}行目: ${lineCode.trim()}`);
                    }
                }

                if (errorLogs.length > 0) {
                    throw ""
                } else {
                    if(selectedFormat == "ips"){
                        outputArea.value = ipsCoding(convertEndian(machineCodeParts), offset)
                    }

                    if(selectedFormat == "edizon"){
                        outputArea.value = cheatCoding(machineCodeParts,offset)
                    }

                    if(selectedFormat == "raw"){
                        outputArea.value = `${offsetHex};\n${machineCodeParts.join('\n')}`
                    }
                }

            } catch (outerError) {
                // tryブロック全体で予期せぬエラーが発生した場合
                outputArea.value = 'アセンブル中に以下のエラーが発生しました:\n' + errorLogs.join('\n' + outerError);
                outputArea.classList.add('error-state'); // エラー時スタイル適用
            }

        }
    </script>
</body>
</html>